<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ρεαλιστική Θάλασσα • Ελεύθερη Κίνηση (GitHub Pages)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b1422; overflow: hidden; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; inset: 0; pointer-events: none; }
    .bar { position: absolute; left: 10px; top: 10px; color:#e6f0ff; background: rgba(0,0,0,.35); padding:8px 10px; border-radius: 10px; font: 13px system-ui; pointer-events:auto; }
    .help { position: absolute; right: 10px; top: 10px; color:#e6f0ff; background: rgba(0,0,0,.35); padding:8px 10px; border-radius: 10px; font: 13px system-ui; pointer-events:auto; }
    .help kbd{background: rgba(255,255,255,.15); padding: 2px 6px; border-radius: 6px;}
    canvas { cursor: grab; }
    canvas.dragging { cursor: grabbing; }
  </style>
  <!-- Global THREE only (χωρίς ES modules) για GitHub Pages -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div class="bar">Θέαση: κλικ & σύρε • Κίνηση: <kbd>WASD</kbd> • Sprint: <kbd>Shift</kbd> • Reset: <kbd>R</kbd></div>
    <div class="help">Ρεαλιστικά κύματα (Gerstner) + άπειρο ωκεανό</div>
  </div>

  <script>
    // ———————————————————————————
    // Σκηνή
    // ———————————————————————————
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1a33, 0.0012);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 50000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Φως + ουρανός
    const sun = new THREE.DirectionalLight(0xffffff, 1.0); sun.position.set(-200, 300, -120);
    scene.add(sun, new THREE.AmbientLight(0x5a7cff, 0.15));
    const skyGeo = new THREE.SphereGeometry(20000, 32, 16);
    const skyMat = new THREE.ShaderMaterial({ side: THREE.BackSide,
      uniforms: { topColor: { value: new THREE.Color(0x86aefc) }, horizonColor: { value: new THREE.Color(0x4b6cb7) }, bottomColor: { value: new THREE.Color(0x0d1424) } },
      vertexShader: `varying vec3 vW; void main(){ vec4 w=modelMatrix*vec4(position,1.0); vW=w.xyz; gl_Position=projectionMatrix*viewMatrix*w; }`,
      fragmentShader: `varying vec3 vW; uniform vec3 topColor,horizonColor,bottomColor; void main(){ float h=normalize(vW).y*.5+.5; vec3 c=mix(bottomColor,mix(horizonColor,topColor,smoothstep(.4,1.,h)),smoothstep(0.,1.,h)); gl_FragColor=vec4(c,1.0);} `
    });
    scene.add(new THREE.Mesh(skyGeo, skyMat));

    // ———————————————————————————
    // ΡΕΑΛΙΣΤΙΚΗ ΘΑΛΑΣΣΑ — Gerstner + άπειρο πλαίσιο
    // ———————————————————————————
    const TILE_SIZE = 8000; // μεγάλο πλακίδιο έτσι ώστε να μην φαίνονται άκρα
    const SEG = 240;
    const seaGeo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE, SEG, SEG); seaGeo.rotateX(-Math.PI/2);

    const uniforms = {
      uTime: { value: 0 },
      uChop: { value: 1.2 },
      uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },
      uDepthColor: { value: new THREE.Color('#09203f') },
      uSurfaceColor: { value: new THREE.Color('#49a7ff') },
      uFoamColor: { value: new THREE.Color('#e7f7ff') },
      uFoamThreshold: { value: 0.68 },
      uColorOffset: { value: 0.08 }, uColorMult: { value: 3.5 },
      uOffset: { value: new THREE.Vector2(0,0) },
      // 5 σετ κυμάτων: swell, mid, wind, chop1, chop2
      w_dir0: { value: new THREE.Vector2( 1.0, 0.2).normalize() }, w_len0: { value: 280.0 }, w_speed0: { value: 10.0 }, w_steep0: { value: 1.2 },
      w_dir1: { value: new THREE.Vector2( 0.6, 1.0).normalize() }, w_len1: { value: 140.0 }, w_speed1: { value: 16.0 }, w_steep1: { value: 1.0 },
      w_dir2: { value: new THREE.Vector2(-0.8, 0.1).normalize() }, w_len2: { value: 90.0 },  w_speed2: { value: 20.0 }, w_steep2: { value: 0.8 },
      w_dir3: { value: new THREE.Vector2( 0.3,-0.9).normalize() }, w_len3: { value: 45.0 },  w_speed3: { value: 24.0 }, w_steep3: { value: 0.6 },
      w_dir4: { value: new THREE.Vector2(-1.0,-0.4).normalize() }, w_len4: { value: 22.0 },  w_speed4: { value: 28.0 }, w_steep4: { value: 0.5 }
    };

    const seaMat = new THREE.ShaderMaterial({ uniforms, fog:true,
      vertexShader: /* glsl */`
        uniform float uTime, uChop; uniform vec2 uOffset;
        uniform vec2 w_dir0, w_dir1, w_dir2, w_dir3, w_dir4;
        uniform float w_len0, w_len1, w_len2, w_len3, w_len4;
        uniform float w_speed0, w_speed1, w_speed2, w_speed3, w_speed4;
        uniform float w_steep0, w_steep1, w_steep2, w_steep3, w_steep4;
        varying vec3 vPos; varying vec3 vNormal; varying float vFoamHint;

        struct Wave { vec2 dir; float len; float speed; float steep; };

        void applyWave(in Wave W, in vec2 xz, inout vec3 P, inout vec3 dPdX, inout vec3 dPdZ){
          vec2 d = normalize(W.dir);
          float k = 6.28318530718 / W.len;     // κυμαριθμός
          float a = W.steep / k;               // πλάτος (με βάση steepness)
          float ph = k * dot(d, xz) - W.speed * uTime;
          float s = sin(ph), c = cos(ph);
          // οριζόντια "κοψίλα" (chop)
          P.x += d.x * a * c * uChop;
          P.z += d.y * a * c * uChop;
          P.y += a * s;
          // παράγωγοι για normal
          vec2 dp = k * d;
          // d/dx
          dPdX.x += -d.x * a * s * uChop * dp.x;
          dPdX.y +=  a * c * dp.x;
          dPdX.z += -d.y * a * s * uChop * dp.x;
          // d/dz
          dPdZ.x += -d.x * a * s * uChop * dp.y;
          dPdZ.y +=  a * c * dp.y;
          dPdZ.z += -d.y * a * s * uChop * dp.y;
        }

        void main(){
          vec3 P = position;
          vec3 dPdX = vec3(1.0, 0.0, 0.0);
          vec3 dPdZ = vec3(0.0, 0.0, 1.0);
          vec2 worldXZ = P.xz + uOffset; // άπειρος ωκεανός: φάση με world coords

          applyWave(Wave(w_dir0, w_len0, w_speed0, w_steep0), worldXZ, P, dPdX, dPdZ);
          applyWave(Wave(w_dir1, w_len1, w_speed1, w_steep1), worldXZ, P, dPdX, dPdZ);
          applyWave(Wave(w_dir2, w_len2, w_speed2, w_steep2), worldXZ, P, dPdX, dPdZ);
          applyWave(Wave(w_dir3, w_len3, w_speed3, w_steep3), worldXZ, P, dPdX, dPdZ);
          applyWave(Wave(w_dir4, w_len4, w_speed4, w_steep4), worldXZ, P, dPdX, dPdZ);

          vPos = P;
          vNormal = normalize(cross(dPdZ, dPdX));
          // απλό hint για αφρό (με βάση μέση steepness)
          float avgSteep = (w_steep0+w_steep1+w_steep2+w_steep3+w_steep4)/5.0;
          vFoamHint = clamp(avgSteep * 0.6, 0.0, 1.0);

          gl_Position = projectionMatrix * modelViewMatrix * vec4(P, 1.0);
        }
      `,
      fragmentShader: /* glsl */`
        uniform vec3 uDepthColor, uSurfaceColor, uFoamColor; 
        uniform float uFoamThreshold, uColorOffset, uColorMult; 
        uniform vec3 uSunDir; 
        varying vec3 vPos; varying vec3 vNormal; varying float vFoamHint;
        void main(){
          vec3 N = normalize(vNormal);
          vec3 V = normalize(-vPos);
          vec3 L = normalize(uSunDir);
          float diff = max(dot(N,L), 0.0);
          float spec = pow(max(dot(reflect(-L,N), V), 0.0), 96.0) * 0.65;

          // Ανάμειξη χρώματος με βάση το ύψος (proxy βάθους)
          float h = clamp((vPos.y + uColorOffset) * uColorMult, 0.0, 1.0);
          vec3 base = mix(uDepthColor, uSurfaceColor, h);

          // Fresnel + αφρός στις κορυφές
          float fres = pow(1.0 - max(dot(N,V), 0.0), 3.0);
          float foam = smoothstep(uFoamThreshold-0.15, uFoamThreshold+0.05, fres + diff*0.35 + vFoamHint*0.5);

          vec3 col = base * (0.28 + 0.9*diff) + spec;
          col = mix(col, uFoamColor, foam);

          // Ομίχλη
          float fogDens = 0.0012; float fogF = 1.0 - exp(-pow(length(vPos)*fogDens, 2.0));
          vec3 fogCol = vec3(0.07,0.14,0.27);
          col = mix(col, fogCol, fogF);

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    const water = new THREE.Mesh(seaGeo, seaMat); water.frustumCulled=false; scene.add(water);

    // ———————————————————————————
    // Παίκτης — ελεύθερη κίνηση, θέαση με drag, επιπλέει στο κύμα
    // ———————————————————————————
    const player = new THREE.Object3D(); scene.add(player); player.add(camera);
    camera.position.set(0,0,0);

    const EYE = 2.0;        // μάτια ~2m πάνω από επιφάνεια
    const SMOOTH = 0.12;    // εξομάλυνση ύψους
    const SPEED = 18;       // m/s
    const RUN = 1.8;        // sprint

    let yaw=0, pitch=0; const keys={f:0,b:0,l:0,r:0,run:0};
    let dragging=false, lastX=0, lastY=0;

    function clampPitch(){ const lim=Math.PI/2-0.01; pitch=Math.max(-lim, Math.min(lim, pitch)); }

    renderer.domElement.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; renderer.domElement.classList.add('dragging'); });
    window.addEventListener('mouseup', ()=>{ dragging=false; renderer.domElement.classList.remove('dragging'); });
    window.addEventListener('mousemove', e=>{ if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; const S=0.003; yaw -= dx*S; pitch -= dy*S; clampPitch(); });
    window.addEventListener('keydown', e=>{ if(e.code==='KeyW')keys.f=1; if(e.code==='KeyS')keys.b=1; if(e.code==='KeyA')keys.l=1; if(e.code==='KeyD')keys.r=1; if(e.code==='ShiftLeft'||e.code==='ShiftRight')keys.run=1; if(e.code==='KeyR') reset(); });
    window.addEventListener('keyup', e=>{ if(e.code==='KeyW')keys.f=0; if(e.code==='KeyS')keys.b=0; if(e.code==='KeyA')keys.l=0; if(e.code==='KeyD')keys.r=0; if(e.code==='ShiftLeft'||e.code==='ShiftRight')keys.run=0; });

    function reset(){ player.position.set(0, 6, 0); yaw=0; pitch=0; }
    reset();

    // Δειγματοληψία ύψους κύματος (ίδια φυσική με shader, σε world coords)
    const W = [
      {dir: uniforms.w_dir0.value, len: uniforms.w_len0.value, speed: uniforms.w_speed0.value, steep: uniforms.w_steep0.value},
      {dir: uniforms.w_dir1.value, len: uniforms.w_len1.value, speed: uniforms.w_speed1.value, steep: uniforms.w_steep1.value},
      {dir: uniforms.w_dir2.value, len: uniforms.w_len2.value, speed: uniforms.w_speed2.value, steep: uniforms.w_steep2.value},
      {dir: uniforms.w_dir3.value, len: uniforms.w_len3.value, speed: uniforms.w_speed3.value, steep: uniforms.w_steep3.value},
      {dir: uniforms.w_dir4.value, len: uniforms.w_len4.value, speed: uniforms.w_speed4.value, steep: uniforms.w_steep4.value},
    ];

    const TWO_PI = Math.PI*2;
    function heightAndGrad(x,z,t){
      let h=0, dhdx=0, dhdz=0;
      for(let i=0;i<W.length;i++){
        const d = W[i].dir.clone().normalize();
        const k = TWO_PI / W[i].len;
        const a = W[i].steep / k;
        const ph = k*(d.x*x + d.y*z) - W[i].speed * t;
        const s = Math.sin(ph), c = Math.cos(ph);
        h += a * s;
        const cka = c * k * a; // derivative multiplier
        dhdx += cka * d.x;
        dhdz += cka * d.y;
      }
      return { h, dhdx, dhdz };
    }

    // Βρόχος
    const clock = new THREE.Clock();
    function animate(){
      const dt = Math.min(clock.getDelta(), 0.05);
      uniforms.uTime.value += dt * 1.15; // ταχύτητα κύματος

      // Κίνηση παίκτη
      player.rotation.y = yaw; camera.rotation.x = pitch;
      const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion); fwd.y=0; fwd.normalize();
      const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();
      const mx = (keys.r-keys.l), mz=(keys.f-keys.b);
      if(mx||mz){ const sp=SPEED*(keys.run?RUN:1); player.position.addScaledVector(fwd, mz*sp*dt); player.position.addScaledVector(right, mx*sp*dt); }

      // Άπειρος ωκεανός: μετακινούμε το πλακίδιο να ακολουθεί τον παίκτη
      water.position.set(player.position.x, 0, player.position.z);
      uniforms.uOffset.value.set(water.position.x, water.position.z);

      // Επιπλέει στο κύμα + ελαφρύς προσανατολισμός με βάση κλίση
      const t = uniforms.uTime.value;
      const { h, dhdx, dhdz } = heightAndGrad(player.position.x, player.position.z, t);
      const targetY = h + EYE;
      player.position.y += (targetY - player.position.y) * SMOOTH;

      // μικρή κλίση κάμερας για ρεαλισμό (με βάση κλίση κύματος)
      const tiltX = -Math.atan(dhdz) * 0.15; // pitch tilt από κλίση προς z
      const tiltZ =  Math.atan(dhdx) * 0.15; // roll tilt από κλίση προς x
      camera.rotation.x = pitch + tiltX;
      camera.rotation.z = tiltZ;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Μέγεθος
    window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
  </script>
</body>
</html>
