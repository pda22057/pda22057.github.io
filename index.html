<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Swim POV • Rough Sea (Three.js)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b1422; overflow: hidden; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .panel {
      pointer-events: auto;
      color: #e6f0ff; background: rgba(0,0,0,.5); 
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 14px 16px; border-radius: 12px; backdrop-filter: blur(6px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      text-align: center;
    }
    .mini { position: fixed; left: 10px; bottom: 10px; color:#e6f0ff; opacity:.88; background: rgba(0,0,0,.35); padding:8px 10px; border-radius: 10px; font:12px system-ui; }
    kbd{background: rgba(255,255,255,.15); padding: 2px 6px; border-radius: 6px;}
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div id="lockPanel" class="panel">
      <div style="font-size:18px; margin-bottom:6px;">Click to start swimming</div>
      <div>Mouse to look • <kbd>WASD</kbd> move • <kbd>Shift</kbd> sprint • <kbd>R</kbd> reset • <kbd>Enter</kbd> lock</div>
      <div style="margin-top:6px; opacity:.9">No mouse look? Use <kbd>← →</kbd> to turn, <kbd>↑ ↓</kbd> to look (fallback).</div>
    </div>
  </div>
  <div class="mini">POV swimmer • waves follow camera height</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';
    import GUI from 'https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js';

    const container = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0b1a33, 0.0016);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 20000);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    // Pointer lock (first-person)
    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    const lockPanel = document.getElementById('lockPanel');
    const lock = ()=> controls.lock();
    lockPanel.addEventListener('click', lock);
    renderer.domElement.addEventListener('click', ()=>{ if(!controls.isLocked) controls.lock(); });
    addEventListener('keydown', e=>{ if(e.code==='Enter' && !controls.isLocked) controls.lock(); });
    controls.addEventListener('lock', ()=> lockPanel.style.display = 'none');
    controls.addEventListener('unlock', ()=> lockPanel.style.display = 'grid');

    // Light
    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(-60, 120, -20);
    scene.add(sun, new THREE.AmbientLight(0x5a7cff, 0.18));

    // Sky dome
    const skyGeo = new THREE.SphereGeometry(8000, 32, 16);
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: {
        topColor: { value: new THREE.Color(0x8fb3ff) },
        horizonColor: { value: new THREE.Color(0x4b6cb7) },
        bottomColor: { value: new THREE.Color(0x0d1424) }
      },
      vertexShader: `varying vec3 vW; void main(){ vec4 w=modelMatrix*vec4(position,1.0); vW=w.xyz; gl_Position=projectionMatrix*viewMatrix*w; }`,
      fragmentShader: `varying vec3 vW; uniform vec3 topColor,horizonColor,bottomColor; void main(){ float h=normalize(vW).y*.5+.5; vec3 c=mix(bottomColor,mix(horizonColor,topColor,smoothstep(.4,1.,h)),smoothstep(0.,1.,h)); gl_FragColor=vec4(c,1.0);} `
    });
    scene.add(new THREE.Mesh(skyGeo, skyMat));

    // Water surface (visible tri-sine waves)
    const SIZE = 6000;
    const SEG = 200;
    const geo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
    geo.rotateX(-Math.PI/2);

    const uniforms = {
      uTime: { value: 0 },
      // wave sets — keep in sync with CPU sampler below
      uAmp1: { value: 16.0 }, uLen1: { value: 140.0 }, uSpd1: { value: 1.2 }, uDir1: { value: new THREE.Vector2(1,0.2).normalize() },
      uAmp2: { value: 8.5 }, uLen2: { value: 70.0 },  uSpd2: { value: 1.8 }, uDir2: { value: new THREE.Vector2(0.6,1).normalize() },
      uAmp3: { value: 4.0 }, uLen3: { value: 32.0 },  uSpd3: { value: 2.6 }, uDir3: { value: new THREE.Vector2(-0.7,0.2).normalize() },
      uDepthColor: { value: new THREE.Color('#0b1c34') },
      uSurfaceColor: { value: new THREE.Color('#4db5ff') },
      uFoamColor: { value: new THREE.Color('#e7f7ff') },
      uFoam: { value: 0.68 },
      uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() }
    };

    const waterMat = new THREE.ShaderMaterial({
      uniforms,
      fog: true,
      vertexShader: /* glsl */`
        uniform float uTime; 
        uniform float uAmp1,uLen1,uSpd1; uniform vec2 uDir1;
        uniform float uAmp2,uLen2,uSpd2; uniform vec2 uDir2;
        uniform float uAmp3,uLen3,uSpd3; uniform vec2 uDir3;
        varying vec3 vPos; varying vec3 vNormal;
        
        vec3 wave(vec3 p, float amp, float len, float spd, vec2 dir, float t){
          float k = 6.28318530718 / len;
          float phase = k * dot(normalize(dir), p.xz) - t * spd;
          float h = sin(phase) * amp;
          p.y += h;
          p.x += dir.x * cos(phase) * amp * 0.45;
          p.z += dir.y * cos(phase) * amp * 0.45;
          return p;
        }
        void main(){
          vec3 p = position;
          p = wave(p, uAmp1, uLen1, uSpd1, uDir1, uTime*1.0);
          p = wave(p, uAmp2, uLen2, uSpd2, uDir2, uTime*1.2);
          p = wave(p, uAmp3, uLen3, uSpd3, uDir3, uTime*1.5);
          // normals (approx via screen-space derivatives)
          vec3 dx = dFdx(p); vec3 dz = dFdy(p);
          vNormal = normalize(cross(dz, dx));
          vPos = p;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
        }
      `,
      fragmentShader: /* glsl */`
        uniform vec3 uDepthColor,uSurfaceColor,uFoamColor; 
        uniform float uFoam; uniform vec3 uSunDir; 
        varying vec3 vPos; varying vec3 vNormal;
        void main(){
          vec3 N = normalize(vNormal);
          vec3 V = normalize(-vPos);
          vec3 L = normalize(uSunDir);
          float diff = max(dot(N,L),0.0);
          float spec = pow(max(dot(reflect(-L,N),V),0.0), 64.0) * 0.7;
          float h = clamp((vPos.y + 10.0)/40.0, 0.0, 1.0);
          vec3 base = mix(uDepthColor, uSurfaceColor, h);
          float fres = pow(1.0 - max(dot(N,V), 0.0), 3.0);
          float foam = smoothstep(uFoam-0.15, uFoam+0.05, fres + diff*0.4);
          vec3 col = base * (0.25 + diff*0.95) + spec;
          col = mix(col, uFoamColor, foam);
          // fog
          float d = length(vPos);
          float f = 1.0 - exp(-pow(d*0.0016, 2.0));
          col = mix(col, vec3(0.07,0.14,0.27), f);
          gl_FragColor = vec4(col,1.0);
        }
      `
    });

    const water = new THREE.Mesh(geo, waterMat);
    water.frustumCulled = false;
    scene.add(water);

    // ——————— GUI ———————
    const gui = new GUI({ title: 'Sea Controls' });
    gui.add(uniforms.uAmp1, 'value', 4, 35, 0.1).name('Swell Amp');
    gui.add(uniforms.uLen1, 'value', 60, 260, 1).name('Swell Length');
    gui.add(uniforms.uSpd1, 'value', 0.4, 3, 0.01).name('Swell Speed');
    gui.add(uniforms.uAmp2, 'value', 2, 18, 0.1).name('Wind Amp');
    gui.add(uniforms.uLen2, 'value', 30, 140, 1).name('Wind Length');
    gui.add(uniforms.uSpd2, 'value', 0.6, 5, 0.01).name('Wind Speed');
    gui.add(uniforms.uAmp3, 'value', 1, 12, 0.1).name('Chop Amp');
    gui.add(uniforms.uLen3, 'value', 10, 80, 1).name('Chop Length');
    gui.add(uniforms.uSpd3, 'value', 0.8, 8, 0.01).name('Chop Speed');
    gui.add(uniforms.uFoam, 'value', 0.4, 0.95, 0.01).name('Foam Threshold');

    // ——————— Swim physics (float on wave height) ———————
    const EYE_HEIGHT = 2.0;           // eyes above water
    const SMOOTH = 0.12;              // follow smoothing 0..1
    const BASE_SPEED = 18;            // meters per second across surface
    const RUN_MULT = 1.8;             // Shift multiplier

    const keys = { f:0, b:0, l:0, r:0, run:0 };
    const turn = { left:0, right:0, up:0, down:0 };
    addEventListener('keydown', (e)=>{
      if(e.code==='KeyW') keys.f=1; if(e.code==='KeyS') keys.b=1; if(e.code==='KeyA') keys.l=1; if(e.code==='KeyD') keys.r=1; if(e.code==='ShiftLeft'||e.code==='ShiftRight') keys.run=1;
      if(e.code==='ArrowLeft') turn.left=1; if(e.code==='ArrowRight') turn.right=1; if(e.code==='ArrowUp') turn.up=1; if(e.code==='ArrowDown') turn.down=1;
      if(e.code==='KeyR'){ resetPlayer(); }
    });
    addEventListener('keyup', (e)=>{
      if(e.code==='KeyW') keys.f=0; if(e.code==='KeyS') keys.b=0; if(e.code==='KeyA') keys.l=0; if(e.code==='KeyD') keys.r=0; if(e.code==='ShiftLeft'||e.code==='ShiftRight') keys.run=0;
      if(e.code==='ArrowLeft') turn.left=0; if(e.code==='ArrowRight') turn.right=0; if(e.code==='ArrowUp') turn.up=0; if(e.code==='ArrowDown') turn.down=0;
    });

    let yaw = 0, pitch = 0; // fallback orientation
    function resetPlayer(){
      const obj = controls.getObject();
      obj.position.set(0, 6, 0);
      yaw = 0; pitch = 0; camera.rotation.set(0,0,0);
    }
    resetPlayer();

    // CPU-side wave sampler to keep camera on surface
    const TWO_PI = Math.PI * 2;
    function heightAndGrad(x, z, t){
      const sets = [
        { amp: uniforms.uAmp1.value, len: uniforms.uLen1.value, spd: uniforms.uSpd1.value, dir: uniforms.uDir1.value },
        { amp: uniforms.uAmp2.value, len: uniforms.uLen2.value, spd: uniforms.uSpd2.value, dir: uniforms.uDir2.value },
        { amp: uniforms.uAmp3.value, len: uniforms.uLen3.value, spd: uniforms.uSpd3.value, dir: uniforms.uDir3.value },
      ];
      let h = 0, dhdx = 0, dhdz = 0;
      for(const s of sets){
        const d = new THREE.Vector2().copy(s.dir).normalize();
        const k = TWO_PI / s.len;
        const phase = k * (d.x * x + d.y * z) - t * s.spd;
        h += Math.sin(phase) * s.amp;
        const c = Math.cos(phase) * k * s.amp;
        dhdx += c * d.x;
        dhdz += c * d.y;
      }
      return { h, dhdx, dhdz };
    }

    function updateFallbackRotation(dt){
      if(!controls.isLocked){
        const TURN = 1.8; // rad/s
        yaw += (turn.right - turn.left) * TURN * dt;
        pitch += (turn.up - turn.down) * TURN * dt;
        const lim = Math.PI/2 - 0.01;
        pitch = Math.max(-lim, Math.min(lim, pitch));
        camera.rotation.set(pitch, yaw, 0);
      }
    }

    // Animate
    const clock = new THREE.Clock();
    function animate(){
      const dt = Math.min(clock.getDelta(), 0.05);
      uniforms.uTime.value += dt * 1.25;

      updateFallbackRotation(dt);

      // movement on XZ regardless of lock (fallback uses yaw)
      const obj = controls.getObject();
      const dir = new THREE.Vector3();
      if(controls.isLocked){
        camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
      } else {
        dir.set(Math.sin(yaw), 0, -Math.cos(yaw));
      }
      const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
      let moveX = (keys.r - keys.l), moveZ = (keys.f - keys.b);
      if(moveX || moveZ){
        const speed = BASE_SPEED * (keys.run? RUN_MULT : 1);
        obj.position.addScaledVector(dir, moveZ * speed * dt);
        obj.position.addScaledVector(right, moveX * speed * dt);
      }

      // sample wave height at player position
      const t = uniforms.uTime.value;
      const sample = heightAndGrad(obj.position.x, obj.position.z, t);
      const targetY = sample.h + 2.0; // EYE_HEIGHT
      obj.position.y += (targetY - obj.position.y) * SMOOTH;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

  </script>
</body>
</html>
