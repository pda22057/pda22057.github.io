<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rough Sea • Three.js (Gerstner Waves)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: linear-gradient(#88a7d5, #2b3959 55%, #101827); overflow: hidden; }
    #app { position: fixed; inset: 0; }
    .hint {
      position: fixed; left: 12px; bottom: 12px; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: #e6f0ff; opacity: .85; background: rgba(0,0,0,.25); padding: 8px 10px; border-radius: 10px; backdrop-filter: blur(6px);
    }
    .hint kbd { background: rgba(255,255,255,.15); padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hint">Drag to orbit • Scroll to zoom • <kbd>R</kbd> reset view</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import GUI from 'https://unpkg.com/lil-gui@0.19/dist/lil-gui.esm.js';

    // ————————————————————————————————————————————————
    // Scene setup
    // ————————————————————————————————————————————————
    const container = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x1a2740, 0.0005);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 10000);
    camera.position.set(-120, 45, 120);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI * 0.49; // keep above water
    controls.target.set(0, 5, 0);

    // Lighting (simple sun + ambient)
    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(-60, 120, -20);
    scene.add(sun);
    scene.add(new THREE.AmbientLight(0x6188ff, 0.15));

    // Sky dome (large inverted sphere with gradient)
    const skyGeo = new THREE.SphereGeometry(4000, 32, 16);
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: {
        topColor: { value: new THREE.Color(0x8fb3ff) },
        horizonColor: { value: new THREE.Color(0x4b6cb7) },
        bottomColor: { value: new THREE.Color(0x0d1424) }
      },
      vertexShader: /* glsl */`
        varying vec3 vWorld;
        void main(){
          vec4 wPos = modelMatrix * vec4(position, 1.0);
          vWorld = wPos.xyz;
          gl_Position = projectionMatrix * viewMatrix * wPos;
        }
      `,
      fragmentShader: /* glsl */`
        varying vec3 vWorld;
        uniform vec3 topColor; uniform vec3 horizonColor; uniform vec3 bottomColor;
        void main(){
          float h = normalize(vWorld).y * .5 + .5; // 0..1
          vec3 c = mix(bottomColor, mix(horizonColor, topColor, smoothstep(0.4, 1.0, h)), smoothstep(0.0, 1.0, h));
          gl_FragColor = vec4(c, 1.0);
        }
      `
    });
    scene.add(new THREE.Mesh(skyGeo, skyMat));

    // ————————————————————————————————————————————————
    // Water (Gerstner waves in the vertex shader)
    // ————————————————————————————————————————————————
    const SIZE = 4000;
    const SEG = 300; // increase for higher detail (costly)
    const geo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG);
    geo.rotateX(-Math.PI/2);

    const uniforms = {
      uTime: { value: 0 },
      uChop: { value: 1.0 },
      uDepthColor: { value: new THREE.Color('#0e2547') },
      uSurfaceColor: { value: new THREE.Color('#4db5ff') },
      uFoamColor: { value: new THREE.Color('#e7f7ff') },
      uColorOffset: { value: 0.08 },
      uColorMult: { value: 3.0 },
      uFoamThreshold: { value: 0.72 },
      uSunDir: { value: new THREE.Vector3().copy(sun.position).normalize() },

      // Three wave sets
      wA_dir: { value: new THREE.Vector2(1.0, 0.2).normalize() },
      wA_steep: { value: 1.0 },
      wA_len: { value: 180.0 },
      wA_speed: { value: 10.0 },

      wB_dir: { value: new THREE.Vector2(0.6, 1.0).normalize() },
      wB_steep: { value: 0.7 },
      wB_len: { value: 90.0 },
      wB_speed: { value: 16.0 },

      wC_dir: { value: new THREE.Vector2(-0.9, 0.1).normalize() },
      wC_steep: { value: 0.5 },
      wC_len: { value: 45.0 },
      wC_speed: { value: 22.0 },
    };

    const waterMat = new THREE.ShaderMaterial({
      uniforms,
      transparent: false,
      fog: true,
      vertexShader: /* glsl */`
        uniform float uTime; uniform float uChop;
        uniform vec2 wA_dir, wB_dir, wC_dir; 
        uniform float wA_steep, wB_steep, wC_steep;
        uniform float wA_len, wB_len, wC_len;
        uniform float wA_speed, wB_speed, wC_speed;
        varying vec3 vPos; varying vec3 vNormal; varying float vFoam;

        // Gerstner helpers
        struct Wave { vec2 dir; float steep; float len; float speed; };

        // Returns displaced position and partial derivatives for normal
        void gerstner(in Wave w, in vec3 pos, in float time, inout vec3 P, inout vec3 dPdX, inout vec3 dPdZ){
          float k = 2.0 * 3.14159265 / w.len;   // wavenumber
          float a = w.steep / k;                // amplitude (steepness-scaled)
          float phase = k * (dot(w.dir, pos.xz)) - w.speed * k * time;
          float s = sin(phase), c = cos(phase);

          // Choppy waves (horizontal displacement)
          P.x += (w.dir.x * a * c) * uChop;
          P.z += (w.dir.y * a * c) * uChop;
          P.y += a * s;

          // Partials for normal (d/dx and d/dz)
          vec2 dPhase = k * w.dir;
          // d/dx
          dPdX.x += -w.dir.x * w.dir.x * a * s * uChop * dPhase.x;
          dPdX.y +=  a * c * dPhase.x;
          dPdX.z += -w.dir.y * w.dir.x * a * s * uChop * dPhase.x;
          // d/dz
          dPdZ.x += -w.dir.x * w.dir.y * a * s * uChop * dPhase.y;
          dPdZ.y +=  a * c * dPhase.y;
          dPdZ.z += -w.dir.y * w.dir.y * a * s * uChop * dPhase.y;
        }

        void main(){
          Wave A = Wave(normalize(wA_dir), wA_steep, wA_len, wA_speed);
          Wave B = Wave(normalize(wB_dir), wB_steep, wB_len, wB_speed);
          Wave C = Wave(normalize(wC_dir), wC_steep, wC_len, wC_speed);

          vec3 P = position; // starting position
          vec3 dPdX = vec3(1.0, 0.0, 0.0);
          vec3 dPdZ = vec3(0.0, 0.0, 1.0);

          gerstner(A, position, uTime, P, dPdX, dPdZ);
          gerstner(B, position, uTime, P, dPdX, dPdZ);
          gerstner(C, position, uTime, P, dPdX, dPdZ);

          vPos = P;
          vNormal = normalize(cross(dPdZ, dPdX));

          // simple foam hint from curvature (length of normal derivatives proxy)
          float choppy = uChop * 0.6;
          float steepnessMix = (wA_steep + wB_steep + wC_steep) / 3.0;
          vFoam = clamp(steepnessMix * choppy, 0.0, 1.0);

          gl_Position = projectionMatrix * modelViewMatrix * vec4(P, 1.0);
        }
      `,
      fragmentShader: /* glsl */`
        uniform vec3 uDepthColor, uSurfaceColor, uFoamColor; 
        uniform float uColorOffset, uColorMult, uFoamThreshold; 
        uniform vec3 uSunDir;
        varying vec3 vPos; varying vec3 vNormal; varying float vFoam;

        void main(){
          vec3 N = normalize(vNormal);
          vec3 V = normalize(-vPos);
          vec3 L = normalize(uSunDir);

          // Fresnel-ish term
          float fres = pow(1.0 - max(dot(N, V), 0.0), 3.0);

          // Simple diffuse + specular
          float diff = max(dot(N, L), 0.0);
          float spec = pow(max(dot(reflect(-L, N), V), 0.0), 64.0) * 0.55;

          // Depth-based color mix (y ~ height acts like relative depth here)
          float h = clamp((vPos.y + uColorOffset) * uColorMult, 0.0, 1.0);
          vec3 base = mix(uDepthColor, uSurfaceColor, h);

          // Foam thresholding
          float foam = smoothstep(uFoamThreshold - 0.15, uFoamThreshold + 0.05, fres + diff*0.35 + vFoam*0.5);

          vec3 col = base * (0.25 + diff * 0.9) + spec * 1.0;
          col = mix(col, uFoamColor, foam);

          // Fog (exp2 to match scene fog)
          float fogDensity = 0.0005;
          float fogFactor = 1.0 - exp(-pow(length(vPos) * fogDensity, 2.0));
          vec3 fogColor = vec3(0.10, 0.16, 0.30);
          col = mix(col, fogColor, fogFactor);

          gl_FragColor = vec4(col, 1.0);
        }
      `
    });

    const water = new THREE.Mesh(geo, waterMat);
    water.frustumCulled = false; // avoid popping at edges
    scene.add(water);

    // ————————————————————————————————————————————————
    // GUI controls
    // ————————————————————————————————————————————————
    const gui = new GUI({ title: 'Rough Sea Controls' });
    gui.domElement.style.userSelect = 'none';

    const wavesFolder = gui.addFolder('Waves');
    const params = {
      chop: 1.1,
      A_dir: 12, A_len: 180, A_steep: 1.0, A_speed: 10,
      B_dir: 55, B_len: 90,  B_steep: 0.7, B_speed: 16,
      C_dir: -10, C_len: 45, C_steep: 0.5, C_speed: 22,
      foam: 0.72
    };

    wavesFolder.add(params, 'chop', 0.0, 2.0, 0.01).name('Choppiness').onChange(v=> uniforms.uChop.value = v);
    wavesFolder.add(params, 'A_dir', -180, 180, 1).name('Swell Dir (°)').onChange(v=>{
      const r = THREE.MathUtils.degToRad(v); uniforms.wA_dir.value.set(Math.cos(r), Math.sin(r)).normalize();
    });
    wavesFolder.add(params, 'A_len', 60, 400, 1).name('Swell Length').onChange(v=> uniforms.wA_len.value = v);
    wavesFolder.add(params, 'A_steep', 0.1, 2.0, 0.01).name('Swell Steep').onChange(v=> uniforms.wA_steep.value = v);
    wavesFolder.add(params, 'A_speed', 2, 25, 0.1).name('Swell Speed').onChange(v=> uniforms.wA_speed.value = v);

    wavesFolder.add(params, 'B_dir', -180, 180, 1).name('Wind Dir (°)').onChange(v=>{
      const r = THREE.MathUtils.degToRad(v); uniforms.wB_dir.value.set(Math.cos(r), Math.sin(r)).normalize();
    });
    wavesFolder.add(params, 'B_len', 30, 200, 1).name('Wind Length').onChange(v=> uniforms.wB_len.value = v);
    wavesFolder.add(params, 'B_steep', 0.1, 1.5, 0.01).name('Wind Steep').onChange(v=> uniforms.wB_steep.value = v);
    wavesFolder.add(params, 'B_speed', 2, 35, 0.1).name('Wind Speed').onChange(v=> uniforms.wB_speed.value = v);

    wavesFolder.add(params, 'C_dir', -180, 180, 1).name('Chop Dir (°)').onChange(v=>{
      const r = THREE.MathUtils.degToRad(v); uniforms.wC_dir.value.set(Math.cos(r), Math.sin(r)).normalize();
    });
    wavesFolder.add(params, 'C_len', 10, 120, 1).name('Chop Length').onChange(v=> uniforms.wC_len.value = v);
    wavesFolder.add(params, 'C_steep', 0.0, 1.2, 0.01).name('Chop Steep').onChange(v=> uniforms.wC_steep.value = v);
    wavesFolder.add(params, 'C_speed', 2, 45, 0.1).name('Chop Speed').onChange(v=> uniforms.wC_speed.value = v);

    gui.add(params, 'foam', 0.4, 0.95, 0.01).name('Foam Threshold').onChange(v=> uniforms.uFoamThreshold.value = v);

    // Initialize GUI-linked uniforms
    uniforms.uChop.value = params.chop;
    uniforms.wA_len.value = params.A_len; uniforms.wA_steep.value = params.A_steep; uniforms.wA_speed.value = params.A_speed;
    uniforms.wB_len.value = params.B_len; uniforms.wB_steep.value = params.B_steep; uniforms.wB_speed.value = params.B_speed;
    uniforms.wC_len.value = params.C_len; uniforms.wC_steep.value = params.C_steep; uniforms.wC_speed.value = params.C_speed;
    uniforms.uFoamThreshold.value = params.foam;

    // ————————————————————————————————————————————————
    // Animate
    // ————————————————————————————————————————————————
    const clock = new THREE.Clock();
    function animate(){
      const dt = clock.getDelta();
      uniforms.uTime.value += dt;
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // ————————————————————————————————————————————————
    // Resize + helpers
    // ————————————————————————————————————————————————
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase() === 'r'){
        camera.position.set(-120, 45, 120);
        controls.target.set(0, 5, 0);
        controls.update();
      }
    });

  </script>
</body>
</html>
